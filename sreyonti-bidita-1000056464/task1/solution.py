# -*- coding: utf-8 -*-
"""solution

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TTXng6VSO7xUC1595g_ykwBpg-bq46Jk
"""

import numpy as np
import heapq
import matplotlib.pyplot as plt
import time
import pandas as pd

from google.colab import files
uploaded = files.upload()

grid1 = pd.read_csv("map1.csv", header=None).values
grid2 = pd.read_csv("map2.csv", header=None).values
grid3 = pd.read_csv("map3.csv", header=None).values

maps = [grid1, grid2, grid3]

def load_grid_from_csv(file_path):
    return np.loadtxt(file_path, delimiter=',', dtype=int)

grid = load_grid_from_csv("map1.csv")
print(grid)

#0=free, 1=obstacle
grid = np.array([
    [0, 0, 0, 0, 0],
    [0, 1, 1, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 1, 0]
    ])

start = (0, 0)
goal = (4, 4)

grid.shape

start

goal

class Node:
    def __init__(self, position, g=0, h=0, parent=None):
        self.position = position
        self.g = g
        self.h = h
        self.f = g + h
        self.parent = parent

    def __lt__(self, other):
        return self.f < other.f

def heuristic(a, b, type="manhattan"):
    if type == "manhattan":
        return abs(a[0] - b[0]) + abs(a[1] - b[1])
    elif type == "euclidean":
        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5

def get_neighbors(position, grid):
    neighbors = []
    directions = [(-1,0), (1,0), (0,-1), (0,1)]
    for dr, dc in directions:
        r, c = position[0] + dr, position[1] + dc
        if 0 <= r < grid.shape[0] and 0 <= c < grid.shape[1]:
            if grid[r][c] == 0:
                neighbors.append((r, c))
    return neighbors

def reconstruct_path(node):
    path = []
    while node:
        path.append(node.position)
        node = node.parent
    return path[::-1]

get_neighbors((2,2), grid)

def dijkstra(grid, start, goal):
    open_list = []
    visited = set()
    start_node = Node(position=start, g=0)
    heapq.heappush(open_list, start_node)

    while open_list:
        current_node = heapq.heappop(open_list)
        if current_node.position == goal:
            return reconstruct_path(current_node), visited

        visited.add(current_node.position)

        for neighbor in get_neighbors(current_node.position, grid):
            if neighbor in visited:
                continue
            g_cost = current_node.g + 1
            neighbor_node = Node(position=neighbor, g=g_cost, parent=current_node)
            heapq.heappush(open_list, neighbor_node)

    return None, visited

def astar(grid, start, goal):
    open_list = []
    visited = set()
    start_node = Node(position=start, g=0, h=heuristic(start, goal))
    heapq.heappush(open_list, start_node)

    while open_list:
        current_node = heapq.heappop(open_list)
        if current_node.position == goal:
            return reconstruct_path(current_node), visited

        visited.add(current_node.position)

        for neighbor in get_neighbors(current_node.position, grid):
            if neighbor in visited:
                continue
            g_cost = current_node.g + 1
            h_cost = heuristic(neighbor, goal)
            neighbor_node = Node(position=neighbor, g=g_cost, h=h_cost, parent=current_node)
            heapq.heappush(open_list, neighbor_node)

    return None, visited

def visualize(grid, path=None, explored=None, start=None, goal=None):
    display = np.copy(grid).astype(float)

    if explored:
        for r, c in explored:
            if display[r, c] == 0:
                display[r, c] = 0.5

    if path:
        for r, c in path:
            if display[r, c] != 1:
                display[r, c] = 0.8

    if start:
        display[start] = 0.2
    if goal:
        display[goal] = 0.9

    plt.imshow(display, cmap="gray")
    plt.title("Grid with Path and Explored Nodes")
    plt.show()

def run_and_visualize(algorithm, grid, start, goal):
    t0 = time.time()
    path, explored = algorithm(grid, start, goal)
    t1 = time.time()
    visualize(grid, path=path, explored=explored, start=start, goal=goal)

    if path:
        print("Path found")
        print("Path length:", len(path) - 1)
    else:
        print("No path found")

    print("Time:", round((t1 - t0) * 1000, 2), "ms")
    return (t1 - t0) * 1000, len(path) - 1 if path else None, path is not None

starts = [(0, 0), (0, 0), (0, 0)]
goals = [(3, 5), (3, 5), (3, 5)]

import pandas as pd

def benchmark_algorithm(algorithm, grid, start, goal, runs=5):
    times, lengths, successes = [], [], []
    for _ in range(runs):
        t, length, success = run_and_visualize(algorithm, grid, start, goal)
        times.append(t)
        lengths.append(length)
        successes.append(success)
    return times, lengths, successes

results = []

for i, grid in enumerate(maps):
    start, goal = starts[i], goals[i]

    # Dijkstra benchmark
    d_times, d_lengths, d_success = benchmark_algorithm(dijkstra, grid, start, goal)
    d_summary = {
        "Map": f"map{i+1}",
        "Algorithm": "Dijkstra",
        "Avg Runtime (ms)": np.mean(d_times),
        "Avg Path Length": np.mean([l for l in d_lengths if l is not None]),
        "Success Rate (%)": 100 * np.sum(d_success) / len(d_success)
    }
    results.append(d_summary)

    # A* benchmark
    a_times, a_lengths, a_success = benchmark_algorithm(astar, grid, start, goal)
    a_summary = {
        "Map": f"map{i+1}",
        "Algorithm": "A*",
        "Avg Runtime (ms)": np.mean(a_times),
        "Avg Path Length": np.mean([l for l in a_lengths if l is not None]),
        "Success Rate (%)": 100 * np.sum(a_success) / len(a_success)
    }
    results.append(a_summary)

df = pd.DataFrame(results)
print(df)